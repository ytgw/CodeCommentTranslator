{"version":3,"sources":["sourceCodeAnalyzer.ts","programmingLanguage.ts","commentConfig.tsx","preprocess.ts","appMainComponents.tsx","app.tsx","index.tsx"],"names":["Comment","start","end","startPattern","endPattern","type","this","toPattern","str","replace","StringLiteral","SourceCodeAnalyzer","typeChangers","typedTexts","nextInfo","hasResidual","residualText","isInSrc","changer","undefined","sourceCode","setState","info","pattern","getPattern","typeFromPattern","spacePattern","map","join","addTypedTexts","firstType","array","RegExp","exec","text","sidx","index","eidx","length","slice","filter","p","startPattern2typeChanger","concat","test","Error","ProgramLang","name","lineComments","blockComments","stringLiterals","val","changers","push","obj","ProgramLangsContainer","langs","conf","getName","LangConfig","props","lang2optionElement","lang","value","state","stringLeterals","onChange","onLangChange","langsContainer","getLangs","getLineComments","getBlockComments","getStringLeterals","idx","inputElements","i","e","onLineCommentsChange","target","toString","setStrings","isStart","label","setString","onSetStringChange","renderSetString","onBlockCommentsChange","onStringLiteralsChange","event","preventDefault","isCustomLang","setLineComments","setBlockComments","setStringLeterals","messages","v","alert","onSubmit","renderCustomLineComment","renderCustomBlockComment","renderCustomStringLiteral","className","commentElement","renderCustomLang","renderNormalLang","renderSelectLang","React","Component","LineFormatter","comment","hasSrc","specialChar","startRegExp","endRegExp","t","nextLineFormatter","needsNewLine","getComment","endsHyphenComment","next","result","everyCommentLike","hasAnyComment","CommentFormatter","lineFormatters","document","splitByNewLine","format","texts","typedText","indexOf","newLineNum","lineFormatter","addStr","getAppendComment","includes","repeat","preprocessSourceCode","getTextTypeChangers","getDocument","SourceInput","placeholder","wrap","PreProcessButton","style","backgroundColor","isHighlight","onClick","PreProcessResult","TranslatorButton","AppMain","onSourceInputChange","sourceInput","shouldPreProcessed","onPreProcessButtonClick","preProcessResult","shouldTranslated","onPreProcessResultChange","onTranslatorButtonClick","translationResult","url","encodeURI","window","open","App","name2lang","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.452775f5.chunk.js","sourcesContent":["type TextType = 'source' | 'typeChanger' | 'comment' | 'stringLiteral'\n\ntype NextInfo = {isInSrc: true, changer: undefined} | {isInSrc: false, changer: TextTypeChanger};\n\nexport interface TypedText {\n  text: string,\n  type: TextType,\n}\n\nexport interface SetString {\n  start: string,\n  end: string,\n}\n\nexport interface TextTypeChanger {\n  startPattern: string,\n  endPattern: string,\n  type: TextType,\n}\n\ninterface Analyzer {\n  type: (sourceCode: string) => TypedText[],\n}\n\n\n// ======================================================================\nexport class Comment implements TextTypeChanger {\n  readonly startPattern: string;\n  readonly endPattern: string;\n  readonly type: TextType;\n\n  constructor(start: string, end: string) {\n    this.startPattern = this.toPattern(start);\n    this.endPattern = this.toPattern(end);\n    this.type = 'comment';\n  }\n\n  private toPattern(str: string): string {\n    return str.replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&');\n  }\n}\n\n\n// ======================================================================\nexport class StringLiteral implements TextTypeChanger {\n  readonly startPattern: string;\n  readonly endPattern: string;\n  readonly type: TextType;\n\n  constructor(start: string, end: string) {\n    this.startPattern = this.toPattern(start);\n    this.endPattern = this.toPattern(end);\n    this.type = 'stringLiteral';\n  }\n\n  private toPattern(str: string): string {\n    return str.replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&');\n  }\n}\n\n\n// ======================================================================\nexport class SourceCodeAnalyzer implements Analyzer {\n  private typedTexts: TypedText[];\n  private nextInfo: NextInfo;\n  private hasResidual: boolean;\n  private residualText: string;\n  private readonly typeChangers: TextTypeChanger[];\n\n  constructor(typeChangers: TextTypeChanger[]) {\n    this.typedTexts = [];\n    this.nextInfo = {isInSrc: true, changer: undefined};\n    this.hasResidual = true;\n    this.residualText = '';\n    this.typeChangers = typeChangers;\n  }\n\n  type(sourceCode: string): TypedText[] {\n    const nextInfo: NextInfo = {isInSrc: true, changer: undefined};\n    this.setState([], nextInfo, true, sourceCode);\n    while (this.hasResidual) {\n      const sourceCode = this.residualText;\n      const info: NextInfo = this.nextInfo;\n      const pattern = this.getPattern();\n      this.typeFromPattern(sourceCode, pattern, info);\n    }\n\n    return this.typedTexts;\n  }\n\n  private getPattern(): string {\n    // 変化文字の前後に0個以上の改行を除くスペースライク文字があるパターン。\n    const spacePattern = '[^\\\\S\\\\n]*';\n    let pattern: string;\n    if (this.nextInfo.changer === undefined) {\n      pattern = this.typeChangers.map(\n        changer => `(${spacePattern}${changer.startPattern}${spacePattern})`\n      ).join('|');\n    } else {\n      pattern = spacePattern + this.nextInfo.changer.endPattern + spacePattern;\n    }\n\n    return pattern;\n  }\n\n  private setState(typedTexts: TypedText[], nextInfo: NextInfo, hasResidual: boolean, residualText: string): void {\n    this.typedTexts = typedTexts;\n    this.nextInfo = nextInfo;\n    this.hasResidual = hasResidual;\n    this.residualText = residualText;\n  }\n\n  private typeFromPattern(sourceCode: string, pattern: string, info: NextInfo): void {\n    const firstType: TextType = info.isInSrc ? 'source' : info.changer.type;\n    const regex = new RegExp(pattern);\n    const array = regex.exec(sourceCode);\n\n    let addTypedTexts: TypedText[];\n    let nextInfo: NextInfo;\n    let hasResidual: boolean;\n    let residualText: string;\n    if (array === null) {\n      addTypedTexts = [{text: sourceCode, type: firstType}];\n      nextInfo = info;\n      hasResidual = false;\n      residualText = '';\n    } else {\n      const sidx = array.index;\n      const eidx = array.index + array[0].length;\n      addTypedTexts = [\n        {text: sourceCode.slice(0, sidx), type: firstType},\n        {text: sourceCode.slice(sidx, eidx), type: 'typeChanger'},\n      ];\n      addTypedTexts = addTypedTexts.filter(p => p.text !== '');\n      if (info.isInSrc) {\n        nextInfo = {isInSrc: false, changer: this.startPattern2typeChanger(array[0])};\n      } else {\n        nextInfo = {isInSrc: true, changer: undefined};\n      }\n      hasResidual = (eidx < sourceCode.length);\n      residualText = sourceCode.slice(eidx, sourceCode.length);\n    }\n\n    const typedTexts = this.typedTexts.concat(addTypedTexts);\n    this.setState(typedTexts, nextInfo, hasResidual, residualText);\n  }\n\n  private startPattern2typeChanger(str: string): TextTypeChanger {\n    for (const changer of this.typeChangers) {\n      const pattern = changer.startPattern;\n      const regex = new RegExp(pattern);\n      if (regex.test(str)) {\n        return changer;\n      }\n    }\n    throw new Error('パターンが見つかりません。');\n  }\n}\n","import {SetString, TextTypeChanger, Comment, StringLiteral} from './sourceCodeAnalyzer';\n\nexport type ProgramLangName = 'JavaScript or TypeScript' | 'C or C++' | 'Python' | 'Shell' | 'Custom'\n\n\n// ======================================================================\nexport class ProgramLang {\n  private readonly name: ProgramLangName;\n  private lineComments: string[];\n  private blockComments: SetString[];\n  private stringLiterals: SetString[];\n\n  constructor(name: ProgramLangName, lineComments: string[], blockComments: SetString[], stringLiterals: SetString[]) {\n    this.name = name;\n    this.lineComments = lineComments.filter(str => str !== '');\n    this.blockComments = blockComments.filter(val => (val.start !== '') && (val.end !== ''));\n    this.stringLiterals = stringLiterals.filter(val => (val.start !== '') && (val.end !== ''));\n  }\n\n  getName(): ProgramLangName {\n    return this.name;\n  }\n\n  getLineComments(): string[] {\n    return this.lineComments;\n  }\n\n  setLineComments(lineComments: string[]): void {\n    this.lineComments = lineComments.filter(str => str !== '');\n  }\n\n  getBlockComments(): SetString[] {\n    return this.blockComments;\n  }\n\n  setBlockComments(blockComments: SetString[]): void {\n    this.blockComments = blockComments.filter(val => (val.start !== '') && (val.end !== ''));\n  }\n\n  getStringLeterals(): SetString[] {\n    return this.stringLiterals;\n  }\n\n  setStringLeterals(stringLiterals: SetString[]): void {\n    this.stringLiterals = stringLiterals.filter(val => (val.start !== '') && (val.end !== ''));\n  }\n\n  getTextTypeChangers(): TextTypeChanger[] {\n    const changers: TextTypeChanger[] = [];\n    changers.push(...this.lineComments.map(str => new Comment(str, '\\n')));\n    changers.push(...this.blockComments.map(obj => new Comment(obj.start, obj.end)));\n    changers.push(...this.stringLiterals.map(obj => new StringLiteral(obj.start, obj.end)));\n    return changers;\n  }\n}\n\n\n// ======================================================================\nexport class ProgramLangsContainer {\n  private readonly langs: ProgramLang[] = [\n    new ProgramLang('JavaScript or TypeScript', ['//'], [{start: '/*', end: '*/'}], [{start: '\\'', end: '\\''}, {start: '\"', end: '\"'}, {start: '`', end: '`'}]),\n    new ProgramLang('C or C++', ['//'], [{start: '/*', end: '*/'}], [{start: '\\'', end: '\\''}, {start: '\"', end: '\"'}]),\n    new ProgramLang('Python', ['#'], [{start: '\"\"\"', end: '\"\"\"'}, {start: '\\'\\'\\'', end: '\\'\\'\\''}], [{start: '\\'', end: '\\''}, {start: '\"', end: '\"'}]),\n    new ProgramLang('Shell', ['#'], [], [{start: '\\'', end: '\\''}, {start: '\"', end: '\"'}, {start: '`', end: '`'}]),\n    new ProgramLang('Custom', [], [], []),\n  ]\n\n  getLangs(): ProgramLang[] {\n    return this.langs;\n  }\n\n  name2lang(name: ProgramLangName): ProgramLang {\n    const langs: ProgramLang[] = this.langs.filter(conf => conf.getName() === name);\n    return langs[0];\n  }\n}\n","import React from 'react';\nimport {SetString} from './sourceCodeAnalyzer';\nimport {ProgramLang, ProgramLangsContainer} from './programmingLanguage';\nimport './index.css';\n\ntype LangConfigProps = {\n  lang: ProgramLang,\n  langsContainer: ProgramLangsContainer,\n  isCustomLang: boolean,\n  onLangChange: (event: React.ChangeEvent<HTMLSelectElement>) => void,\n}\n\ntype LangConfigState = {\n  lineComments: string[],\n  blockComments: SetString[],\n  stringLeterals: SetString[],\n}\n\nexport class LangConfig extends React.Component<LangConfigProps, LangConfigState> {\n  constructor(props: LangConfigProps) {\n    super(props);\n    this.state = {\n      lineComments: [],\n      blockComments: [],\n      stringLeterals: [],\n    };\n  }\n\n  lang2optionElement = (lang: ProgramLang): JSX.Element => {\n    const name = lang.getName();\n    return (\n      <option value={name} key={name}>{name}</option>\n    );\n  }\n\n  renderSelectLang(): JSX.Element {\n    return (\n      <select value={this.props.lang.getName()} onChange={this.props.onLangChange}>\n        {this.props.langsContainer.getLangs().map(this.lang2optionElement)}\n      </select>\n    );\n  }\n\n  renderNormalLang(): JSX.Element {\n    const lineComments = this.props.lang.getLineComments();\n    const blockComments = this.props.lang.getBlockComments();\n    const stringLeterals = this.props.lang.getStringLeterals();\n    return (\n      <>\n        ラインコメント：{lineComments.map(str => `「${str}」`).join(', ')}\n        <br />\n        ブロックコメント：{blockComments.map(obj => `「${obj.start}〜${obj.end}」`).join(', ')}\n        <br />\n        文字列リテラル：{stringLeterals.map(obj => `「${obj.start}〜${obj.end}」`).join(', ')}\n      </>\n    );\n  }\n\n  onLineCommentsChange(str: string, idx: number): void {\n    const lineComments = this.state.lineComments;\n    if (idx < lineComments.length) {\n      lineComments[idx] = str;\n    } else {\n      lineComments.push(str);\n    }\n    this.setState({lineComments: lineComments});\n  }\n\n  renderCustomLineComment(): JSX.Element {\n    const lineComments = this.state.lineComments;\n    const inputElements: (string | JSX.Element)[] = ['ラインコメント：「'];\n    for (let i = 0; i <= lineComments.length; i++) {\n      const value = (i === lineComments.length) ? '' : lineComments[i];\n      inputElements.push(\n        <input\n          type=\"text\"\n          value={value}\n          onChange={(e): void => this.onLineCommentsChange(e.target.value, i)}\n          key={'lineComment' + i.toString()}\n        />\n      );\n      inputElements.push('」、');\n    }\n    return <>{inputElements}</>;\n  }\n\n  onSetStringChange(setStrings: SetString[], str: string, idx: number, isStart: boolean): SetString[] {\n    let start: string;\n    let end: string;\n    if (idx < setStrings.length) {\n      start = isStart ? str : setStrings[idx].start;\n      end = !isStart ? str : setStrings[idx].end;\n      setStrings[idx] = {start, end};\n    } else {\n      start = isStart ? str : '';\n      end = !isStart ? str : '';\n      setStrings.push({start, end});\n    }\n    return setStrings;\n  }\n\n  renderSetString(\n    label: string,\n    setString: SetString[],\n    onChange: (str: string, idx: number, isStart: boolean) => void\n  ): JSX.Element {\n    const inputElements: (string | JSX.Element)[] = [label + '：「'];\n    for (let i = 0; i <= setString.length; i++) {\n      const value = (i === setString.length) ? {start: '', end: ''} : setString[i];\n      inputElements.push(\n        <input\n          type=\"text\"\n          value={value.start}\n          onChange={(e): void => onChange(e.target.value, i, true)}\n          key={'blockCommentStart' + i.toString()}\n        />\n      );\n      inputElements.push('〜');\n      inputElements.push(\n        <input\n          type=\"text\"\n          value={value.end}\n          onChange={(e): void => onChange(e.target.value, i, false)}\n          key={'blockCommentEnd' + i.toString()}\n        />\n      );\n      inputElements.push('」、');\n    }\n    return <>{inputElements}</>;\n  }\n\n  onBlockCommentsChange(str: string, idx: number, isStart: boolean): void {\n    let blockComments = this.state.blockComments;\n    blockComments = this.onSetStringChange(blockComments, str, idx, isStart);\n    this.setState({blockComments: blockComments});\n  }\n\n  renderCustomBlockComment(): JSX.Element {\n    const blockComments = this.state.blockComments;\n    const onChange = (str: string, idx: number, isStart: boolean): void => this.onBlockCommentsChange(str, idx, isStart);\n    return this.renderSetString('ブロックコメント', blockComments, onChange);\n  }\n\n  onStringLiteralsChange(str: string, idx: number, isStart: boolean): void {\n    let stringLiterals = this.state.stringLeterals;\n    stringLiterals = this.onSetStringChange(stringLiterals, str, idx, isStart);\n    this.setState({stringLeterals: stringLiterals});\n  }\n\n  renderCustomStringLiteral(): JSX.Element {\n    const stringLiterals = this.state.stringLeterals;\n    const onChange = (str: string, idx: number, isStart: boolean): void => this.onStringLiteralsChange(str, idx, isStart);\n    return this.renderSetString('文字列リテラル', stringLiterals, onChange);\n  }\n\n  onSubmit(event: React.FormEvent<HTMLFormElement>): void {\n    event.preventDefault();\n    if (this.props.isCustomLang) {\n      this.props.lang.setLineComments(this.state.lineComments);\n      this.props.lang.setBlockComments(this.state.blockComments);\n      this.props.lang.setStringLeterals(this.state.stringLeterals);\n    }\n\n    const messages: string[] = [\n      'Customプログラム言語のコメント設定が反映されました。',\n      'ラインコメント：「' + this.props.lang.getLineComments().join('」、「') + '」',\n      'ブロックコメント：' + this.props.lang.getBlockComments().map(v => `「${v.start}〜${v.end}」`).join('、'),\n      '文字リテラル：' + this.props.lang.getStringLeterals().map(v => `「${v.start}〜${v.end}」`).join('、'),\n    ];\n    alert(messages.join('\\n'));\n  }\n\n  renderCustomLang(): JSX.Element {\n    return (\n      <form onSubmit={(e): void => this.onSubmit(e)}>\n        {this.renderCustomLineComment()}\n        <br />\n        {this.renderCustomBlockComment()}\n        <br />\n        {this.renderCustomStringLiteral()}\n        <br />\n        <input type=\"submit\" value=\"入力内容を設定\" className=\"Submit\" />\n      </form>\n    );\n  }\n\n  render(): JSX.Element {\n    const commentElement = this.props.isCustomLang ? this.renderCustomLang() : this.renderNormalLang();\n    return (\n      <div className=\"CommentConfig\">\n        プログラミング言語：{this.renderSelectLang()}\n        <br />\n        {commentElement}\n      </div>\n    );\n  }\n}","import {ProgramLang} from './programmingLanguage';\nimport {TypedText, SourceCodeAnalyzer} from './sourceCodeAnalyzer';\n\n\n// ======================================================================\nclass LineFormatter {\n  private readonly comment: string;\n  private readonly hasSrc: boolean;\n\n  constructor(typedTexts: TypedText[]) {\n    // 行頭と行末の特殊文字を削除したい。\n    // そのために、1個以上の特殊文字の前後に、0個以上のスペースライク文字があるパターンを作成\n    let specialChar = '(';\n    for (const char of '#$%&=^~\\\\|@+*<>?/') {\n      specialChar += '|' + char.replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&');\n    }\n    specialChar += ')*';\n    const pattern = '(\\\\s*)' + specialChar + '(\\\\s*)';\n\n    const startRegExp = new RegExp(`^${pattern}`);\n    const endRegExp = new RegExp(`${pattern}$`);\n\n    // 空リストに対するmapは空リストを返し、空リストに対するjoinは空文字列を返す。\n    typedTexts = typedTexts.filter(t => t.text.length > 0);\n    const comment = typedTexts.filter(t => t.type === 'comment').map(t => t.text).join(' ');\n    // 行頭と行末の特殊文字を削除。\n    this.comment = comment.replace(startRegExp, '').replace(endRegExp, '');\n\n    this.hasSrc = typedTexts.filter(\n      t => (t.type === 'source') || (t.type === 'stringLiteral')\n    ).length > 0;\n  }\n\n  getComment(): string {\n    return this.comment;\n  }\n\n  getAppendComment(nextLineFormatter: LineFormatter): string {\n    // 改行が必要な場合は、コメント+改行\n    if (this.needsNewLine(nextLineFormatter)) {\n      return this.getComment() + '\\n';\n    }\n    // 改行が不要な場合で、現在行の末尾文字がハイフンなら、ハイフンを消したコメント\n    if (this.endsHyphenComment()) {\n      return this.getComment().replace(/-$/, '');\n    }\n    // それ以外の改行が不要な場合は、コメント+空白\n    return this.getComment() + ' ';\n  }\n\n  private needsNewLine(next: LineFormatter): boolean {\n    // 基本は改行必要\n    let result = true;\n    // コメントライクのみの行が連続するときは改行不要\n    if (this.everyCommentLike() && next.everyCommentLike()) {\n      result = false;\n    }\n    // ただし、現在行か次行がコメントを一つも含まない場合は改行必要\n    if (!this.hasAnyComment() || !next.hasAnyComment()) {\n      result = true;\n    }\n    return result;\n  }\n\n  private everyCommentLike(): boolean {\n    return !this.hasSrc;\n  }\n\n  private hasAnyComment(): boolean {\n    return this.comment.length > 0;\n  }\n\n  private endsHyphenComment(): boolean {\n    return this.comment.slice(-1)[0] === '-';\n  }\n}\n\n\n// ======================================================================\nclass CommentFormatter {\n  private readonly typedTexts: TypedText[];\n  private readonly lineFormatters: LineFormatter[];\n  private readonly document: string;\n\n  constructor(typedTexts: TypedText[]) {\n    this.typedTexts = typedTexts;\n    this.lineFormatters = this.splitByNewLine();\n    this.document = this.format();\n  }\n\n  getDocument(): string {\n    return this.document;\n  }\n\n  private splitByNewLine(): LineFormatter[] {\n    const result: LineFormatter[] = [];\n    let texts: TypedText[] = [];\n    for (const typedText of this.typedTexts) {\n      const type = typedText.type;\n      let residualText = typedText.text;\n\n      let idx: number;\n      while ((idx = residualText.indexOf('\\n')) !== -1) {\n        // str.slice(0,0)は空文字列を返す。\n        texts.push({text: residualText.slice(0, idx), type: type});\n        result.push(new LineFormatter(texts));\n        texts = [];\n        // str.slice(length)は空文字列を返す。\n        residualText = residualText.slice(idx+1);\n      }\n      texts.push({text: residualText, type: type});\n    }\n    return result;\n  }\n\n  private format(): string {\n    if (this.lineFormatters.length === 0) {\n      return '';\n    }\n    let result = '';\n    let newLineNum = 0;\n    for (let i = 0; i < this.lineFormatters.length - 1; i++) {\n      const lineFormatter = this.lineFormatters[i];\n      const nextLineFormatter = this.lineFormatters[i+1];\n\n      let addStr = lineFormatter.getAppendComment(nextLineFormatter);\n      if (!addStr.includes('\\n')) {\n        newLineNum += 1;\n      } else {\n        addStr += '\\n'.repeat(newLineNum);\n        newLineNum = 0;\n      }\n      result += addStr;\n    }\n\n    // 最終行のコメント\n    result += this.lineFormatters.slice(-1)[0].getComment();\n    return result;\n  }\n}\n\n\n// ======================================================================\nexport function preprocessSourceCode(sourceCode: string, lang: ProgramLang): string {\n  const analyzer = new SourceCodeAnalyzer(lang.getTextTypeChangers());\n  const typedTexts: TypedText[] = analyzer.type(sourceCode);\n  const formatter = new CommentFormatter(typedTexts);\n  const document = formatter.getDocument();\n\n  return document;\n}\n","import React from 'react';\nimport './index.css';\n\n\n// ======================================================================\ntype SourceInputProps = {\n  value: string,\n  onChange: (event: React.ChangeEvent<HTMLTextAreaElement>) => void\n}\n\nexport function SourceInput(props: SourceInputProps): JSX.Element {\n  return (\n    <form>\n      <textarea\n        placeholder=\"翻訳したいソースコードを入力してください。\"\n        wrap=\"off\"\n        value={props.value}\n        onChange={props.onChange}\n      />\n    </form>\n  );\n}\n\n\n// ======================================================================\ntype PreProcessButtonProps = {\n  isHighlight: boolean,\n  onClick: () => void\n}\n\nexport function PreProcessButton(props: PreProcessButtonProps): JSX.Element {\n  const style: React.CSSProperties = {\n    backgroundColor: props.isHighlight ? '#ffeeee' : undefined,\n  };\n\n  return (\n    <button style={style} onClick={props.onClick}>\n      前処理\n    </button>\n  );\n}\n\n\n// ======================================================================\ntype PreProcessResultProps = {\n  result: string\n  onChange: (event: React.ChangeEvent<HTMLTextAreaElement>) => void\n}\n\nexport function PreProcessResult(props: PreProcessResultProps): JSX.Element {\n  return (\n    <form>\n      <textarea\n        placeholder=\"前処理ボタンを押してください。\"\n        wrap=\"off\"\n        value={props.result}\n        onChange={props.onChange}\n      />\n    </form>\n  );\n}\n\n\n// ======================================================================\ntype TranslatorButtonProps = {\n  isHighlight: boolean,\n  onClick: () => void\n}\n\nexport function TranslatorButton(props: TranslatorButtonProps): JSX.Element {\n  const style: React.CSSProperties = {\n    backgroundColor: props.isHighlight ? '#ffeeee' : undefined,\n  };\n\n  return (\n    <button style={style} onClick={props.onClick}>\n      翻訳サイトへ\n    </button>\n  );\n}\n\n\n// ======================================================================\ntype TranslationResultProps = {\n  result: string\n}\n\nexport function TranslationResult(props: TranslationResultProps): JSX.Element {\n  return (\n    <form>\n      <textarea\n        placeholder=\"翻訳ボタンを押してください。\"\n        wrap=\"off\"\n        readOnly={true}\n        value={props.result}\n      />\n    </form>\n  );\n}\n","import React from 'react';\nimport {ProgramLang} from './programmingLanguage';\nimport {preprocessSourceCode} from './preprocess';\nimport {SourceInput, PreProcessButton, PreProcessResult, TranslatorButton} from './appMainComponents';\nimport './index.css';\n\n\n// ======================================================================\ntype AppMainProps = {\n  lang: ProgramLang,\n}\n\ntype AppMainState = {\n  sourceInput: string,\n  preProcessResult: string,\n  translationResult: string,\n  shouldPreProcessed: boolean,\n  shouldTranslated: boolean,\n}\n\nexport class AppMain extends React.Component<AppMainProps, AppMainState> {\n  constructor(props: AppMainProps) {\n    super(props);\n    this.state = {\n      sourceInput: '',\n      preProcessResult: '',\n      translationResult: '',\n      shouldPreProcessed: false,\n      shouldTranslated: false,\n    };\n  }\n\n  onSourceInputChange = (event: React.ChangeEvent<HTMLTextAreaElement>): void => {\n    this.setState({\n      sourceInput: event.target.value,\n      shouldPreProcessed: true,\n    });\n  }\n\n  onPreProcessButtonClick = (): void => {\n    if (this.props.lang.getTextTypeChangers().length === 0) {\n      const message = 'ラインコメント、ブロックコメント、文字リテラルのいずれかを設定してください。';\n      alert(message);\n      return;\n    }\n    this.setState({\n      preProcessResult: preprocessSourceCode(this.state.sourceInput, this.props.lang),\n      shouldPreProcessed: false,\n      shouldTranslated: true,\n    });\n  }\n\n  onPreProcessResultChange = (event: React.ChangeEvent<HTMLTextAreaElement>): void => {\n    this.setState({\n      preProcessResult: event.target.value,\n      shouldTranslated: true,\n    });\n  }\n\n  onTranslatorButtonClick = (): void => {\n    this.setState({\n      translationResult: 'Generate From PreProcessResult\\n-----\\n' + this.state.preProcessResult,\n      shouldTranslated: false,\n    });\n    const url = 'https://www.deepl.com/translator#en/ja/' + encodeURI(this.state.preProcessResult.replace(/\\n{2,}/g, '\\n\\n'));\n    window.open(url, '_blank');\n  }\n\n  render(): JSX.Element {\n    return (\n      <div className=\"AppMain\">\n        <div className=\"AppMainForm\">\n          <span>ソースコード入力フォーム</span>\n          <br />\n          <SourceInput value={this.state.sourceInput} onChange={this.onSourceInputChange} />\n        </div>\n        <div className=\"AppMainButton\">\n          <PreProcessButton isHighlight={this.state.shouldPreProcessed} onClick={this.onPreProcessButtonClick} />\n        </div>\n        <div className=\"AppMainForm\">\n          <span>前処理結果</span>\n          <br />\n          <PreProcessResult result={this.state.preProcessResult} onChange={this.onPreProcessResultChange} />\n        </div>\n        <div className=\"AppMainButton\">\n          <TranslatorButton isHighlight={this.state.shouldTranslated} onClick={this.onTranslatorButtonClick} />\n        </div>\n        {/* <div className=\"AppMainForm\">\n          <span>翻訳結果</span>\n          <br />\n          <TranslationResult result={this.state.translationResult} />\n        </div> */}\n      </div>\n    );\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport {ProgramLang, ProgramLangsContainer, ProgramLangName} from './programmingLanguage';\nimport {LangConfig} from './commentConfig';\nimport {AppMain} from './app';\nimport './index.css';\n\n\n// ======================================================================\ntype Empty = Record<string, never>\n\ntype AppState = {\n  lang: ProgramLang,\n}\n\nexport class App extends React.Component<Empty, AppState> {\n  private readonly langsContainer: ProgramLangsContainer = new ProgramLangsContainer();\n\n  constructor(props: Empty) {\n    super(props);\n    this.state = {\n      lang: this.langsContainer.getLangs()[0]\n    };\n  }\n\n  onLangChange = (event: React.ChangeEvent<HTMLSelectElement>): void => {\n    this.setState({\n      lang: this.langsContainer.name2lang(event.target.value as ProgramLangName)\n    });\n  }\n\n  render(): JSX.Element {\n    return (\n      <>\n        <LangConfig\n          lang={this.state.lang}\n          langsContainer={this.langsContainer}\n          isCustomLang={this.state.lang.getName() === 'Custom'}\n          onLangChange={this.onLangChange}\n        />\n        <AppMain lang={this.state.lang}/>\n      </>\n    );\n  }\n}\n\n\n// ======================================================================\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}