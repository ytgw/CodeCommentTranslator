{"version":3,"sources":["sourceCodeAnalyzer.ts","programmingLanguage.ts","commentConfig.tsx","preprocess.ts","appMainComponents.tsx","app.tsx","index.tsx"],"names":["Comment","start","end","startPattern","endPattern","type","this","toPattern","str","replace","StringLiteral","SourceCodeAnalyzer","typeChangers","typedTexts","nextInfo","hasResidual","residualText","isInSrc","changer","undefined","sourceCode","setState","info","pattern","getPattern","typeFromPattern","spacePattern","map","join","addTypedTexts","firstType","array","RegExp","exec","text","sidx","index","eidx","length","slice","filter","p","startPattern2typeChanger","concat","test","Error","ProgramLang","name","lineComments","blockComments","stringLiterals","val","changers","push","obj","ProgramLangsContainer","langs","conf","getName","LangConfig","props","lang2optionElement","lang","value","state","stringLeterals","onChange","onLangChange","langsContainer","getLangs","getLineComments","getBlockComments","getStringLeterals","idx","inputElements","i","e","onLineCommentsChange","target","toString","pushedTxt","setStrings","isStart","label","setString","onSetStringChange","renderSetString","onBlockCommentsChange","onStringLiteralsChange","event","preventDefault","isCustomLang","setLineComments","setBlockComments","setStringLeterals","lineCommentsMsg","v","blockCommentsMsg","stringLiteralsMsg","alert","onSubmit","renderCustomLineComment","renderCustomBlockComment","renderCustomStringLiteral","className","commentElement","renderCustomLang","renderNormalLang","renderSelectLang","React","Component","LineFormatter","comment","hasSrc","specialChar","startRegExp","endRegExp","t","nextLineFormatter","needsNewLine","getComment","endsHyphenComment","next","result","everyCommentLike","hasAnyComment","CommentFormatter","lineFormatters","document","splitByNewLine","format","texts","typedText","indexOf","newLineNum","lineFormatter","addStr","getAppendComment","includes","repeat","preprocessSourceCode","getTextTypeChangers","getDocument","SourceInput","placeholder","wrap","PreProcessButton","style","backgroundColor","isHighlight","onClick","PreProcessResult","TranslatorButton","AppMain","onSourceInputChange","sourceInput","shouldPreProcessed","onPreProcessButtonClick","preProcessResult","shouldTranslated","onPreProcessResultChange","onTranslatorButtonClick","translationResult","url","encodeURI","window","open","App","name2lang","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.82dde54f.chunk.js","sourcesContent":["type TextType = 'source' | 'typeChanger' | 'comment' | 'stringLiteral'\n\ntype NextInfo = {isInSrc: true, changer: undefined} | {isInSrc: false, changer: TextTypeChanger};\n\nexport interface TypedText {\n  text: string,\n  type: TextType,\n}\n\nexport interface SetString {\n  start: string,\n  end: string,\n}\n\nexport interface TextTypeChanger {\n  startPattern: string,\n  endPattern: string,\n  type: TextType,\n}\n\ninterface Analyzer {\n  type: (sourceCode: string) => TypedText[],\n}\n\n\n// ======================================================================\nexport class Comment implements TextTypeChanger {\n  readonly startPattern: string;\n  readonly endPattern: string;\n  readonly type: TextType;\n\n  constructor(start: string, end: string) {\n    this.startPattern = this.toPattern(start);\n    this.endPattern = this.toPattern(end);\n    this.type = 'comment';\n  }\n\n  private toPattern(str: string): string {\n    return str.replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&');\n  }\n}\n\n\n// ======================================================================\nexport class StringLiteral implements TextTypeChanger {\n  readonly startPattern: string;\n  readonly endPattern: string;\n  readonly type: TextType;\n\n  constructor(start: string, end: string) {\n    this.startPattern = this.toPattern(start);\n    this.endPattern = this.toPattern(end);\n    this.type = 'stringLiteral';\n  }\n\n  private toPattern(str: string): string {\n    return str.replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&');\n  }\n}\n\n\n// ======================================================================\nexport class SourceCodeAnalyzer implements Analyzer {\n  private typedTexts: TypedText[];\n  private nextInfo: NextInfo;\n  private hasResidual: boolean;\n  private residualText: string;\n  private readonly typeChangers: TextTypeChanger[];\n\n  constructor(typeChangers: TextTypeChanger[]) {\n    this.typedTexts = [];\n    this.nextInfo = {isInSrc: true, changer: undefined};\n    this.hasResidual = true;\n    this.residualText = '';\n    this.typeChangers = typeChangers;\n  }\n\n  type(sourceCode: string): TypedText[] {\n    const nextInfo: NextInfo = {isInSrc: true, changer: undefined};\n    this.setState([], nextInfo, true, sourceCode);\n    while (this.hasResidual) {\n      const sourceCode = this.residualText;\n      const info: NextInfo = this.nextInfo;\n      const pattern = this.getPattern();\n      this.typeFromPattern(sourceCode, pattern, info);\n    }\n\n    return this.typedTexts;\n  }\n\n  private getPattern(): string {\n    // 変化文字の前後に0個以上の改行を除くスペースライク文字があるパターン。\n    const spacePattern = '[^\\\\S\\\\n]*';\n    let pattern: string;\n    if (this.nextInfo.changer === undefined) {\n      pattern = this.typeChangers.map(\n        changer => `(${spacePattern}${changer.startPattern}${spacePattern})`\n      ).join('|');\n    } else {\n      pattern = spacePattern + this.nextInfo.changer.endPattern + spacePattern;\n    }\n\n    return pattern;\n  }\n\n  private setState(typedTexts: TypedText[], nextInfo: NextInfo, hasResidual: boolean, residualText: string): void {\n    this.typedTexts = typedTexts;\n    this.nextInfo = nextInfo;\n    this.hasResidual = hasResidual;\n    this.residualText = residualText;\n  }\n\n  private typeFromPattern(sourceCode: string, pattern: string, info: NextInfo): void {\n    const firstType: TextType = info.isInSrc ? 'source' : info.changer.type;\n    const regex = new RegExp(pattern);\n    const array = regex.exec(sourceCode);\n\n    let addTypedTexts: TypedText[];\n    let nextInfo: NextInfo;\n    let hasResidual: boolean;\n    let residualText: string;\n    if (array === null) {\n      addTypedTexts = [{text: sourceCode, type: firstType}];\n      nextInfo = info;\n      hasResidual = false;\n      residualText = '';\n    } else {\n      const sidx = array.index;\n      const eidx = array.index + array[0].length;\n      addTypedTexts = [\n        {text: sourceCode.slice(0, sidx), type: firstType},\n        {text: sourceCode.slice(sidx, eidx), type: 'typeChanger'},\n      ];\n      addTypedTexts = addTypedTexts.filter(p => p.text !== '');\n      if (info.isInSrc) {\n        nextInfo = {isInSrc: false, changer: this.startPattern2typeChanger(array[0])};\n      } else {\n        nextInfo = {isInSrc: true, changer: undefined};\n      }\n      hasResidual = (eidx < sourceCode.length);\n      residualText = sourceCode.slice(eidx, sourceCode.length);\n    }\n\n    const typedTexts = this.typedTexts.concat(addTypedTexts);\n    this.setState(typedTexts, nextInfo, hasResidual, residualText);\n  }\n\n  private startPattern2typeChanger(str: string): TextTypeChanger {\n    for (const changer of this.typeChangers) {\n      const pattern = changer.startPattern;\n      const regex = new RegExp(pattern);\n      if (regex.test(str)) {\n        return changer;\n      }\n    }\n    throw new Error('パターンが見つかりません。');\n  }\n}\n","import {SetString, TextTypeChanger, Comment, StringLiteral} from './sourceCodeAnalyzer';\n\nexport type ProgramLangName = 'JavaScript or TypeScript' | 'C or C++' | 'Python' | 'Shell' | 'Custom'\n\n\n// ======================================================================\nexport class ProgramLang {\n  private readonly name: ProgramLangName;\n  private lineComments: string[];\n  private blockComments: SetString[];\n  private stringLiterals: SetString[];\n\n  constructor(name: ProgramLangName, lineComments: string[], blockComments: SetString[], stringLiterals: SetString[]) {\n    this.name = name;\n    this.lineComments = lineComments.filter(str => str !== '');\n    this.blockComments = blockComments.filter(val => (val.start !== '') && (val.end !== ''));\n    this.stringLiterals = stringLiterals.filter(val => (val.start !== '') && (val.end !== ''));\n  }\n\n  getName(): ProgramLangName {\n    return this.name;\n  }\n\n  getLineComments(): string[] {\n    return this.lineComments;\n  }\n\n  setLineComments(lineComments: string[]): void {\n    this.lineComments = lineComments.filter(str => str !== '');\n  }\n\n  getBlockComments(): SetString[] {\n    return this.blockComments;\n  }\n\n  setBlockComments(blockComments: SetString[]): void {\n    this.blockComments = blockComments.filter(val => (val.start !== '') && (val.end !== ''));\n  }\n\n  getStringLeterals(): SetString[] {\n    return this.stringLiterals;\n  }\n\n  setStringLeterals(stringLiterals: SetString[]): void {\n    this.stringLiterals = stringLiterals.filter(val => (val.start !== '') && (val.end !== ''));\n  }\n\n  getTextTypeChangers(): TextTypeChanger[] {\n    const changers: TextTypeChanger[] = [];\n    changers.push(...this.lineComments.map(str => new Comment(str, '\\n')));\n    changers.push(...this.blockComments.map(obj => new Comment(obj.start, obj.end)));\n    changers.push(...this.stringLiterals.map(obj => new StringLiteral(obj.start, obj.end)));\n    return changers;\n  }\n}\n\n\n// ======================================================================\nexport class ProgramLangsContainer {\n  private readonly langs: ProgramLang[] = [\n    new ProgramLang('JavaScript or TypeScript', ['//'], [{start: '/*', end: '*/'}], [{start: '\\'', end: '\\''}, {start: '\"', end: '\"'}, {start: '`', end: '`'}]),\n    new ProgramLang('C or C++', ['//'], [{start: '/*', end: '*/'}], [{start: '\\'', end: '\\''}, {start: '\"', end: '\"'}]),\n    new ProgramLang('Python', ['#'], [{start: '\"\"\"', end: '\"\"\"'}, {start: '\\'\\'\\'', end: '\\'\\'\\''}], [{start: '\\'', end: '\\''}, {start: '\"', end: '\"'}]),\n    new ProgramLang('Shell', ['#'], [], [{start: '\\'', end: '\\''}, {start: '\"', end: '\"'}, {start: '`', end: '`'}]),\n    new ProgramLang('Custom', [], [], []),\n  ]\n\n  getLangs(): ProgramLang[] {\n    return this.langs;\n  }\n\n  name2lang(name: ProgramLangName): ProgramLang {\n    const langs: ProgramLang[] = this.langs.filter(conf => conf.getName() === name);\n    return langs[0];\n  }\n}\n","import React from 'react';\nimport {SetString} from './sourceCodeAnalyzer';\nimport {ProgramLang, ProgramLangsContainer} from './programmingLanguage';\nimport './index.css';\n\ntype LangConfigProps = {\n  lang: ProgramLang,\n  langsContainer: ProgramLangsContainer,\n  isCustomLang: boolean,\n  onLangChange: (event: React.ChangeEvent<HTMLSelectElement>) => void,\n}\n\ntype LangConfigState = {\n  lineComments: string[],\n  blockComments: SetString[],\n  stringLeterals: SetString[],\n}\n\nexport class LangConfig extends React.Component<LangConfigProps, LangConfigState> {\n  constructor(props: LangConfigProps) {\n    super(props);\n    this.state = {\n      lineComments: [],\n      blockComments: [],\n      stringLeterals: [],\n    };\n  }\n\n  lang2optionElement = (lang: ProgramLang): JSX.Element => {\n    const name = lang.getName();\n    return (\n      <option value={name} key={name}>{name}</option>\n    );\n  }\n\n  renderSelectLang(): JSX.Element {\n    return (\n      <select value={this.props.lang.getName()} onChange={this.props.onLangChange}>\n        {this.props.langsContainer.getLangs().map(this.lang2optionElement)}\n      </select>\n    );\n  }\n\n  renderNormalLang(): JSX.Element {\n    const lineComments = this.props.lang.getLineComments();\n    const blockComments = this.props.lang.getBlockComments();\n    const stringLeterals = this.props.lang.getStringLeterals();\n    return (\n      <>\n        ラインコメント：{lineComments.map(str => `「${str}」`).join(', ')}\n        <br />\n        ブロックコメント：{blockComments.map(obj => `「${obj.start}〜${obj.end}」`).join(', ')}\n        <br />\n        文字列リテラル：{stringLeterals.map(obj => `「${obj.start}〜${obj.end}」`).join(', ')}\n      </>\n    );\n  }\n\n  onLineCommentsChange(str: string, idx: number): void {\n    const lineComments = this.state.lineComments;\n    if (idx < lineComments.length) {\n      lineComments[idx] = str;\n    } else {\n      lineComments.push(str);\n    }\n    this.setState({lineComments: lineComments});\n  }\n\n  renderCustomLineComment(): JSX.Element {\n    const lineComments = this.state.lineComments;\n    const inputElements: (string | JSX.Element)[] = ['ラインコメント：「'];\n    for (let i = 0; i <= lineComments.length; i++) {\n      const value = (i === lineComments.length) ? '' : lineComments[i];\n      inputElements.push(\n        <input\n          type=\"text\"\n          value={value}\n          onChange={(e): void => this.onLineCommentsChange(e.target.value, i)}\n          key={'lineComment' + i.toString()}\n        />\n      );\n      let pushedTxt = '」';\n      if (i < lineComments.length) {\n        pushedTxt += ', 「';\n      }\n      inputElements.push(pushedTxt);\n    }\n    return <>{inputElements}</>;\n  }\n\n  onSetStringChange(setStrings: SetString[], str: string, idx: number, isStart: boolean): SetString[] {\n    let start: string;\n    let end: string;\n    if (idx < setStrings.length) {\n      start = isStart ? str : setStrings[idx].start;\n      end = !isStart ? str : setStrings[idx].end;\n      setStrings[idx] = {start, end};\n    } else {\n      start = isStart ? str : '';\n      end = !isStart ? str : '';\n      setStrings.push({start, end});\n    }\n    return setStrings;\n  }\n\n  renderSetString(\n    label: string,\n    setString: SetString[],\n    onChange: (str: string, idx: number, isStart: boolean) => void\n  ): JSX.Element {\n    const inputElements: (string | JSX.Element)[] = [label + '：「'];\n    for (let i = 0; i <= setString.length; i++) {\n      const value = (i === setString.length) ? {start: '', end: ''} : setString[i];\n      inputElements.push(\n        <input\n          type=\"text\"\n          value={value.start}\n          onChange={(e): void => onChange(e.target.value, i, true)}\n          key={'blockCommentStart' + i.toString()}\n        />\n      );\n      inputElements.push('〜');\n      inputElements.push(\n        <input\n          type=\"text\"\n          value={value.end}\n          onChange={(e): void => onChange(e.target.value, i, false)}\n          key={'blockCommentEnd' + i.toString()}\n        />\n      );\n      let pushedTxt = '」';\n      if (i < setString.length) {\n        pushedTxt += ', 「';\n      }\n      inputElements.push(pushedTxt);\n    }\n    return <>{inputElements}</>;\n  }\n\n  onBlockCommentsChange(str: string, idx: number, isStart: boolean): void {\n    let blockComments = this.state.blockComments;\n    blockComments = this.onSetStringChange(blockComments, str, idx, isStart);\n    this.setState({blockComments: blockComments});\n  }\n\n  renderCustomBlockComment(): JSX.Element {\n    const blockComments = this.state.blockComments;\n    const onChange = (str: string, idx: number, isStart: boolean): void => this.onBlockCommentsChange(str, idx, isStart);\n    return this.renderSetString('ブロックコメント', blockComments, onChange);\n  }\n\n  onStringLiteralsChange(str: string, idx: number, isStart: boolean): void {\n    let stringLiterals = this.state.stringLeterals;\n    stringLiterals = this.onSetStringChange(stringLiterals, str, idx, isStart);\n    this.setState({stringLeterals: stringLiterals});\n  }\n\n  renderCustomStringLiteral(): JSX.Element {\n    const stringLiterals = this.state.stringLeterals;\n    const onChange = (str: string, idx: number, isStart: boolean): void => this.onStringLiteralsChange(str, idx, isStart);\n    return this.renderSetString('文字列リテラル', stringLiterals, onChange);\n  }\n\n  onSubmit(event: React.FormEvent<HTMLFormElement>): void {\n    event.preventDefault();\n    if (this.props.isCustomLang) {\n      this.props.lang.setLineComments(this.state.lineComments);\n      this.props.lang.setBlockComments(this.state.blockComments);\n      this.props.lang.setStringLeterals(this.state.stringLeterals);\n    }\n\n    const lineCommentsMsg = (this.props.lang.getLineComments().length > 0)\n      ? this.props.lang.getLineComments().map(v => `「${v}」`).join(', ')\n      : 'なし';\n    const blockCommentsMsg = (this.props.lang.getBlockComments().length > 0)\n      ? this.props.lang.getBlockComments().map(v => `「${v.start}〜${v.end}」`).join(', ')\n      : 'なし';\n    const stringLiteralsMsg = (this.props.lang.getStringLeterals().length > 0)\n      ? this.props.lang.getStringLeterals().map(v => `「${v.start}〜${v.end}」`).join(', ')\n      : 'なし';\n    const messages: string[] = [\n      'Customプログラム言語の設定が反映されました。',\n      'ラインコメント：' + lineCommentsMsg,\n      'ブロックコメント：' + blockCommentsMsg,\n      '文字リテラル：' + stringLiteralsMsg,\n    ];\n    alert(messages.join('\\n'));\n  }\n\n  renderCustomLang(): JSX.Element {\n    return (\n      <form onSubmit={(e): void => this.onSubmit(e)}>\n        {this.renderCustomLineComment()}\n        <br />\n        {this.renderCustomBlockComment()}\n        <br />\n        {this.renderCustomStringLiteral()}\n        <br />\n        <input type=\"submit\" value=\"入力内容を設定\" className=\"Submit\" />\n      </form>\n    );\n  }\n\n  render(): JSX.Element {\n    const commentElement = this.props.isCustomLang ? this.renderCustomLang() : this.renderNormalLang();\n    return (\n      <div className=\"CommentConfig\">\n        プログラミング言語：{this.renderSelectLang()}\n        <br />\n        {commentElement}\n      </div>\n    );\n  }\n}","import {ProgramLang} from './programmingLanguage';\nimport {TypedText, SourceCodeAnalyzer} from './sourceCodeAnalyzer';\n\n\n// ======================================================================\nclass LineFormatter {\n  private readonly comment: string;\n  private readonly hasSrc: boolean;\n\n  constructor(typedTexts: TypedText[]) {\n    // 行頭と行末の特殊文字を削除したい。\n    // そのために、1個以上の特殊文字の前後に、0個以上のスペースライク文字があるパターンを作成\n    let specialChar = '(';\n    for (const char of '#$%&=^~\\\\|@+*<>?/') {\n      specialChar += '|' + char.replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&');\n    }\n    specialChar += ')*';\n    const pattern = '(\\\\s*)' + specialChar + '(\\\\s*)';\n\n    const startRegExp = new RegExp(`^${pattern}`);\n    const endRegExp = new RegExp(`${pattern}$`);\n\n    // 空リストに対するmapは空リストを返し、空リストに対するjoinは空文字列を返す。\n    typedTexts = typedTexts.filter(t => t.text.length > 0);\n    const comment = typedTexts.filter(t => t.type === 'comment').map(t => t.text).join(' ');\n    // 行頭と行末の特殊文字を削除。\n    this.comment = comment.replace(startRegExp, '').replace(endRegExp, '');\n\n    this.hasSrc = typedTexts.filter(\n      t => (t.type === 'source') || (t.type === 'stringLiteral')\n    ).length > 0;\n  }\n\n  getComment(): string {\n    return this.comment;\n  }\n\n  getAppendComment(nextLineFormatter: LineFormatter): string {\n    // 改行が必要な場合は、コメント+改行\n    if (this.needsNewLine(nextLineFormatter)) {\n      return this.getComment() + '\\n';\n    }\n    // 改行が不要な場合で、現在行の末尾文字がハイフンなら、ハイフンを消したコメント\n    if (this.endsHyphenComment()) {\n      return this.getComment().replace(/-$/, '');\n    }\n    // それ以外の改行が不要な場合は、コメント+空白\n    return this.getComment() + ' ';\n  }\n\n  private needsNewLine(next: LineFormatter): boolean {\n    // 基本は改行必要\n    let result = true;\n    // コメントライクのみの行が連続するときは改行不要\n    if (this.everyCommentLike() && next.everyCommentLike()) {\n      result = false;\n    }\n    // ただし、現在行か次行がコメントを一つも含まない場合は改行必要\n    if (!this.hasAnyComment() || !next.hasAnyComment()) {\n      result = true;\n    }\n    return result;\n  }\n\n  private everyCommentLike(): boolean {\n    return !this.hasSrc;\n  }\n\n  private hasAnyComment(): boolean {\n    return this.comment.length > 0;\n  }\n\n  private endsHyphenComment(): boolean {\n    return this.comment.slice(-1)[0] === '-';\n  }\n}\n\n\n// ======================================================================\nclass CommentFormatter {\n  private readonly typedTexts: TypedText[];\n  private readonly lineFormatters: LineFormatter[];\n  private readonly document: string;\n\n  constructor(typedTexts: TypedText[]) {\n    this.typedTexts = typedTexts;\n    this.lineFormatters = this.splitByNewLine();\n    this.document = this.format();\n  }\n\n  getDocument(): string {\n    return this.document;\n  }\n\n  private splitByNewLine(): LineFormatter[] {\n    const result: LineFormatter[] = [];\n    let texts: TypedText[] = [];\n    for (const typedText of this.typedTexts) {\n      const type = typedText.type;\n      let residualText = typedText.text;\n\n      let idx: number;\n      while ((idx = residualText.indexOf('\\n')) !== -1) {\n        // str.slice(0,0)は空文字列を返す。\n        texts.push({text: residualText.slice(0, idx), type: type});\n        result.push(new LineFormatter(texts));\n        texts = [];\n        // str.slice(length)は空文字列を返す。\n        residualText = residualText.slice(idx+1);\n      }\n      texts.push({text: residualText, type: type});\n    }\n    return result;\n  }\n\n  private format(): string {\n    if (this.lineFormatters.length === 0) {\n      return '';\n    }\n    let result = '';\n    let newLineNum = 0;\n    for (let i = 0; i < this.lineFormatters.length - 1; i++) {\n      const lineFormatter = this.lineFormatters[i];\n      const nextLineFormatter = this.lineFormatters[i+1];\n\n      let addStr = lineFormatter.getAppendComment(nextLineFormatter);\n      if (!addStr.includes('\\n')) {\n        newLineNum += 1;\n      } else {\n        addStr += '\\n'.repeat(newLineNum);\n        newLineNum = 0;\n      }\n      result += addStr;\n    }\n\n    // 最終行のコメント\n    result += this.lineFormatters.slice(-1)[0].getComment();\n    return result;\n  }\n}\n\n\n// ======================================================================\nexport function preprocessSourceCode(sourceCode: string, lang: ProgramLang): string {\n  const analyzer = new SourceCodeAnalyzer(lang.getTextTypeChangers());\n  const typedTexts: TypedText[] = analyzer.type(sourceCode);\n  const formatter = new CommentFormatter(typedTexts);\n  const document = formatter.getDocument();\n\n  return document;\n}\n","import React from 'react';\nimport './index.css';\n\n\n// ======================================================================\ntype SourceInputProps = {\n  value: string,\n  onChange: (event: React.ChangeEvent<HTMLTextAreaElement>) => void\n}\n\nexport function SourceInput(props: SourceInputProps): JSX.Element {\n  return (\n    <form>\n      <textarea\n        placeholder=\"翻訳したいソースコードを入力してください。\"\n        wrap=\"off\"\n        value={props.value}\n        onChange={props.onChange}\n      />\n    </form>\n  );\n}\n\n\n// ======================================================================\ntype PreProcessButtonProps = {\n  isHighlight: boolean,\n  onClick: () => void\n}\n\nexport function PreProcessButton(props: PreProcessButtonProps): JSX.Element {\n  const style: React.CSSProperties = {\n    backgroundColor: props.isHighlight ? '#ffeeee' : undefined,\n  };\n\n  return (\n    <button style={style} onClick={props.onClick}>\n      前処理\n    </button>\n  );\n}\n\n\n// ======================================================================\ntype PreProcessResultProps = {\n  result: string\n  onChange: (event: React.ChangeEvent<HTMLTextAreaElement>) => void\n}\n\nexport function PreProcessResult(props: PreProcessResultProps): JSX.Element {\n  return (\n    <form>\n      <textarea\n        placeholder=\"前処理ボタンを押してください。\"\n        wrap=\"off\"\n        value={props.result}\n        onChange={props.onChange}\n      />\n    </form>\n  );\n}\n\n\n// ======================================================================\ntype TranslatorButtonProps = {\n  isHighlight: boolean,\n  onClick: () => void\n}\n\nexport function TranslatorButton(props: TranslatorButtonProps): JSX.Element {\n  const style: React.CSSProperties = {\n    backgroundColor: props.isHighlight ? '#ffeeee' : undefined,\n  };\n\n  return (\n    <button style={style} onClick={props.onClick}>\n      翻訳サイトへ\n    </button>\n  );\n}\n\n\n// ======================================================================\ntype TranslationResultProps = {\n  result: string\n}\n\nexport function TranslationResult(props: TranslationResultProps): JSX.Element {\n  return (\n    <form>\n      <textarea\n        placeholder=\"翻訳ボタンを押してください。\"\n        wrap=\"off\"\n        readOnly={true}\n        value={props.result}\n      />\n    </form>\n  );\n}\n","import React from 'react';\nimport {ProgramLang} from './programmingLanguage';\nimport {preprocessSourceCode} from './preprocess';\nimport {SourceInput, PreProcessButton, PreProcessResult, TranslatorButton} from './appMainComponents';\nimport './index.css';\n\n\n// ======================================================================\ntype AppMainProps = {\n  lang: ProgramLang,\n}\n\ntype AppMainState = {\n  sourceInput: string,\n  preProcessResult: string,\n  translationResult: string,\n  shouldPreProcessed: boolean,\n  shouldTranslated: boolean,\n}\n\nexport class AppMain extends React.Component<AppMainProps, AppMainState> {\n  constructor(props: AppMainProps) {\n    super(props);\n    this.state = {\n      sourceInput: '',\n      preProcessResult: '',\n      translationResult: '',\n      shouldPreProcessed: false,\n      shouldTranslated: false,\n    };\n  }\n\n  onSourceInputChange = (event: React.ChangeEvent<HTMLTextAreaElement>): void => {\n    this.setState({\n      sourceInput: event.target.value,\n      shouldPreProcessed: true,\n    });\n  }\n\n  onPreProcessButtonClick = (): void => {\n    if (this.props.lang.getTextTypeChangers().length === 0) {\n      const message = 'ラインコメント、ブロックコメント、文字リテラルのいずれかを設定してください。';\n      alert(message);\n      return;\n    }\n    this.setState({\n      preProcessResult: preprocessSourceCode(this.state.sourceInput, this.props.lang),\n      shouldPreProcessed: false,\n      shouldTranslated: true,\n    });\n  }\n\n  onPreProcessResultChange = (event: React.ChangeEvent<HTMLTextAreaElement>): void => {\n    this.setState({\n      preProcessResult: event.target.value,\n      shouldTranslated: true,\n    });\n  }\n\n  onTranslatorButtonClick = (): void => {\n    this.setState({\n      translationResult: 'Generate From PreProcessResult\\n-----\\n' + this.state.preProcessResult,\n      shouldTranslated: false,\n    });\n    const url = 'https://www.deepl.com/translator#en/ja/' + encodeURI(this.state.preProcessResult.replace(/\\n{2,}/g, '\\n\\n'));\n    window.open(url, '_blank');\n  }\n\n  render(): JSX.Element {\n    return (\n      <div className=\"AppMain\">\n        <div className=\"AppMainForm\">\n          <span>ソースコード入力フォーム</span>\n          <br />\n          <SourceInput value={this.state.sourceInput} onChange={this.onSourceInputChange} />\n        </div>\n        <div className=\"AppMainButton\">\n          <PreProcessButton isHighlight={this.state.shouldPreProcessed} onClick={this.onPreProcessButtonClick} />\n        </div>\n        <div className=\"AppMainForm\">\n          <span>前処理結果</span>\n          <br />\n          <PreProcessResult result={this.state.preProcessResult} onChange={this.onPreProcessResultChange} />\n        </div>\n        <div className=\"AppMainButton\">\n          <TranslatorButton isHighlight={this.state.shouldTranslated} onClick={this.onTranslatorButtonClick} />\n        </div>\n        {/* <div className=\"AppMainForm\">\n          <span>翻訳結果</span>\n          <br />\n          <TranslationResult result={this.state.translationResult} />\n        </div> */}\n      </div>\n    );\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport {ProgramLang, ProgramLangsContainer, ProgramLangName} from './programmingLanguage';\nimport {LangConfig} from './commentConfig';\nimport {AppMain} from './app';\nimport './index.css';\n\n\n// ======================================================================\ntype Empty = Record<string, never>\n\ntype AppState = {\n  lang: ProgramLang,\n}\n\nexport class App extends React.Component<Empty, AppState> {\n  private readonly langsContainer: ProgramLangsContainer = new ProgramLangsContainer();\n\n  constructor(props: Empty) {\n    super(props);\n    this.state = {\n      lang: this.langsContainer.getLangs()[0]\n    };\n  }\n\n  onLangChange = (event: React.ChangeEvent<HTMLSelectElement>): void => {\n    this.setState({\n      lang: this.langsContainer.name2lang(event.target.value as ProgramLangName)\n    });\n  }\n\n  render(): JSX.Element {\n    return (\n      <>\n        <LangConfig\n          lang={this.state.lang}\n          langsContainer={this.langsContainer}\n          isCustomLang={this.state.lang.getName() === 'Custom'}\n          onLangChange={this.onLangChange}\n        />\n        <AppMain lang={this.state.lang}/>\n      </>\n    );\n  }\n}\n\n\n// ======================================================================\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}